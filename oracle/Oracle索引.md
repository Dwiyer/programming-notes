#### 索引前置概念

------

1.9 ORACLE ROWID
通过每个行的ROWID，索引Oracle提供了访问单行数据的能力。ROWID其实就是直接指向单独行的线路图。如果想检查重复值或是其他对ROWID本身的引用，可以在任何表中使用和指定rowid列。

 

1.10 选择性
  使用USER_INDEXES视图，该视图中显示了一个distinct_keys列。比较一下唯一键的数量和表中的行数，就可以判断索引的选择性。选择性越高，索引返回的数据就越少。


1.11 群集因子(Clustering Factor)
 Clustering Factor位于USER_INDEXES视图中。该列反映了数据相对于已建索引的列是否显得有序。如果Clustering Factor列的值接近于索引中的树叶块(leaf block)的数目，表中的数据就越有序。如果它的值接近于表中的行数，则表中的数据就不是很有序。


1.12 二元高度(Binary height)
 索引的二元高度对把ROWID返回给用户进程时所要求的I/O量起到关键作用。在对一个索引进行分析后，可以通过查询DBA_INDEXES的B- level列查看它的二元高度。二元高度主要随着表的大小以及被索引的列中值的范围的狭窄程度而变化。索引上如果有大量被删除的行，它的二元高度也会增加。更新索引列也类似于删除操作，因为它增加了已删除键的数目。重建索引可能会降低二元高度。


1.13 快速全局扫描
 从Oracle7.3后就可以使用快速全局扫描(Fast Full Scan)这个选项。这个选项允许Oracle执行一个全局索引扫描操作。快速全局扫描读取B-树索引上所有树叶块。初始化文件中的 DB_FILE_MULTIBLOCK_READ_COUNT参数可以控制同时被读取的块的数目。


1.14 跳跃式扫描
 从Oracle9i开始，索引跳跃式扫描特性可以允许优化器使用组合索引，即便索引的前导列没有出现在WHERE子句中。索引跳跃式扫描比全索引扫描要快的多。





#### 索引数据结构

------

索引是由 ROOT（根块），Branch（茎块）和Leaf（叶子块）三部分组成的，其中最底层的叶子块 主要存储了 key column value（索引列具体值），以及能具体定位到数据所在位置的rowid（此处rowid和查询时候用的rownum不是同一个概念，有兴趣可以百度rownum和rowid的区别）

注意点：索引块和数据块 需要区分，索引块也是占磁盘空间的



数据库IO:连续读，随机读，随机写和连续写

##### B树索引

B-树，B+树

##### 位图索引



##### 哈希索引



##### 聚簇索引



##### 非聚簇索引



#### 索引分类

------

NORMAL

FUNCTION-BASED NORMAL

单列索引

复合索引

函数索引

不可见索引



B树索引(默认类型)
位图索引
HASH索引
索引组织表索引
反转键(reverse key)索引
基于函数的索引
分区索引(本地和全局索引)
位图连接索引





#### 索引应用

------

order by 

order by 列名。会对order by 后面的列进行排序，



distinct 

distinct 会进行排序





#### 索引压缩

------

1.在索引列中(一列或者多列)，如果有多行数值相同，为了提供查询数据速度，可以将索引进行压缩存储。索引最终也是要存储在数据块上，压缩索引是为了减少扫描数据块的个数。
2.可以采用compress N子句方式创建压缩索引。
3.create index index_name on tableName(col1,col2) compress N。 如果N为1，则会对第一列进行压缩存储，N为2,则会对第一列和第二列压缩存储。



#### 索引设计

------

1.适当场合尽量避免回表读
2.组合索引中的列数越少越高效
3.组合索引中有2列时，情况又不一样： 
3.1 组合索引中，等值查询时，无论哪列在前在后都无所谓。 
3.2 组合索引的2列中，如果一列是范围查询，一列是等值查询，则一定要把等值查询放在前面，范围查询列放在后面才能使索引高效。这里是创建索引的时候，等值查询列在组合索引的最前面，范围列在最后面，不是sql语句中的书写顺序。
4.如果单列的查询与组合索引的前置列查询一样，则单列可以不用创建索引，直接利用组合索引来检索数据。最好将该列放在组合索引的第一列
5.经常一起出现在where字句中的列可以创建索引



#### 索引查找

------

INDEX UNIQUE SCAN

INDEX RANGE SCAN

INDEX FULL SCAN

一次读取一个索引块

INDEX FULL SCAN(MIN/MAX)

INDEX FAST FULL SCAN

一次读取多个索引块

TABLE ACCESS BY INDEX ROWID

回表

聚合因子（CLUSTERING FACTOR）：表明有多少临近的索引条目指到不同的数据块。





















#### 索引总结

------

##### 1.2 索引特点： 

第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 

第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。 

第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。 

第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。 

第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 

 

##### 1.3 索引不足：

第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 

第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 

第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 

 

##### 1.4 应该建索引列的特点：

1）在经常需要搜索的列上，可以加快搜索的速度； 

2）在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构； 

3）在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度； 

4）在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的； 

5）在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间； 

6）在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。 

 

##### 1.5 不应该建索引列的特点：

第一，对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。 

第二，对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。 

第三，对于那些定义为blob数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。 

第四，当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。 

 

##### 1.6 限制索引

限制索引是一些没有经验的开发人员经常犯的错误之一。在SQL中有很多陷阱会使一些索引无法使用。下面讨论一些常见的问题：
  1.6.1 使用不等于操作符（<>、!=）   
  下面的查询即使在cust_rating列有一个索引，查询语句仍然执行一次全表扫描。   
  select cust_Id,cust_name from customers where cust_rating <> 'aa';    
把上面的语句改成如下的查询语句，这样，在采用基于规则的优化器而不是基于代价的优化器（更智能）时，将会使用索引。    
 select cust_Id,cust_name from customers where cust_rating < 'aa' or cust_rating > 'aa';
 特别注意：通过把不等于操作符改成OR条件，就可以使用索引，以避免全表扫描。
  1.6.2 使用IS NULL 或IS NOT NULL
  使用IS NULL 或IS NOT NULL同样会限制索引的使用。因为NULL值并没有被定义。在SQL语句中使用NULL会有很多的麻烦。因此建议开发人员在建表时，把需要索引的列设成 NOT NULL。如果被索引的列在某些行中存在NULL值，就不会使用这个索引（除非索引是一个位图索引，关于位图索引在稍后在详细讨论）。**Oracle不会对索引列上包含NULL值的行进行索引。**
  1.6.3 使用函数
  如果不使用基于函数的索引，那么在SQL语句的WHERE子句中对存在索引的列使用函数时，会使优化器忽略掉这些索引。 下面的查询不会使用索引（只要它不是基于函数的索引）
 select empno,ename,deptno from emp where trunc(hiredate)='01-MAY-81';
  把上面的语句改成下面的语句，这样就可以通过索引进行查找。
select empno,ename,deptno from emp where hiredate<(to_date('01-MAY-81')+0.9999);

 1.6.4 比较不匹配的数据类型    
也是比较难于发现的性能问题之一。 注意下面查询的例子，account_number是一个VARCHAR2类型,在account_number字段上有索引。

下面的语句将执行全表扫描：

 select bank_name,address,city,state,zip from banks where account_number = 990354;
 Oracle可以自动把where子句变成to_number(account_number)=990354，这样就限制了索引的使用,改成下面的查询就可以使用索引：
 select bank_name,address,city,state,zip from banks where account_number ='990354';

特别注意：不匹配的数据类型之间比较会让Oracle自动限制索引的使用,即便对这个查询执行Explain Plan也不能让您明白为什么做了一次“全表扫描”。