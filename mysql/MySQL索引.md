#### 索引概述

------

索引模型：哈希表、有序数组和搜索树。

*你心里要有个概念，数据库底层存储的核心就是基于这些数据模型的。每碰到一个新数据库，我们需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适用场景。始终要相信，只要理解事物的本质，那么所有的问题都会迎刃而解。*

在 MySQL 中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。

二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。

##### 数据结构

<u>二叉查找树 -> 平衡二叉树 -> B 树 -> B+ 树</u>

B+树由B树和索引顺序访问方法（ISAM，是不是很熟悉？对，这也是MyISAM引擎最初参考的数据结构）演化而来，但是在实现过程中几乎没有使用B树的情况了。B+树是为磁盘或其他直接存取辅助设备设计的一种平衡查找树，在B+树中，**所有记录节点都是按键值的大小顺序存放在同一层的叶子节点，各叶子节点通过指针进行链接**。

###### B+ 树的插入操作

页分裂、旋转

###### B+ 树的删除操作

B+树使用**填充因子**（fill factor）来控制树的删除变化，填充因子可设的最小值是50%。B+树的删除操作同样必须保证删除后叶子节点中的记录依然按序排列。与插入不同的是，删除根据填充因子的变化来衡量。

##### InnoDB的索引模型

在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为**索引组织表**。InnoDB 使用了 B+ 树索引模型，B+树索引的本质就是B+树在数据库中的实现，所以数据都是存储在 B+ 树中的。每一个索引在 InnoDB 里面对应一棵 B+ 树。而B+树索引在数据库中的一个特点就是**高扇出性**。在B+树索引中，B+树索引只能找到某条记录所在的页，需再根据二分查找法来进一步找到记录所在页的具体位置。

索引类型分为**主键索引**和**非主键索引**。主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为**聚簇索引**（clustered index）。非主键索引的叶子节点内容是主键的值。如果通过非主键索引来查找数据，那么当找到非主键索引的叶子节点后，很有可能还需要根据主键值查找主键索引来得到数据，这种查找方式又被称为书签查找（bookmark lookup）。因为非主键索引不包含行记录的所有数据，这就意味着每页可以存放更多的键值，因此其高度一般都要小于主键索引。在 InnoDB 里，非主键索引也被称为**二级索引**（secondary index）。（*B+树索引可以分为聚集索引与辅助索引（非聚集索引），但是这两者本身都与之前讨论的B+树的数据结构一样，区别仅在于所存放数据的内容。*）

Q：基于主键索引和普通索引的查询有什么区别？

如果是主键查询方式，则只需要搜索主键对应的 B+ 树；如果是普通索引查询方式，则需要先搜索查询字段索引树，得到结果行的主键，再到主键索引树搜索一次。这个过程称为**回表**。也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。

Q：基于上述主键索引和非主键索引的论述，假如对表中某一个字段创建主键后，该字段会以 B+ 树存储，其它字段是否会以 B+ 树存储？







#### 索引维护

------

数据页、页分裂

如果数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。

Q：什么是**数据页**？数据是怎么存储在数据页里的？

InnoDB 的数据是按数据页为单位来读写的。*也即 B+ 树的叶子节点*。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在 InnoDB 中，每个数据页的大小默认是 16KB。B+树的叶子节点是page （页），一个页里面可以存多个行。

InnoDB磁盘管理的最小单位就是“页”，也就是说无论是叶子节点、非叶子节点和行数据，都是存放在页当中。
页组成结构有头部数据、主体数据和尾部数据。
头部数据主要存的是页相关数据，例如上一页、下一页、当前页号等。是一个双向链表结构。
主体数据主要关注索引和数据的存储，也就是我们常说的索引和数据的存储位置。主体数据当中有一个“User Records”的概念，用来存储索引和数据，是一个单链表结构。
User Records根据节点的不同，User Records又分为四种不同类型：主键索引树叶子节点和非叶子节点，二级索引树叶子节点和非叶子节点。
有了页和User Records的认识，其实说叶子节点存的是页是一种笼统的回答，基于我的理解，我认为叶子节点（主键索引树叶子节点）存放的是行数据更为贴切。

##### 自增主键

自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。

**显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。**





#### 索引查询

##### 覆盖索引

非主键索引树即可覆盖查询结果，而无需回表。由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。

##### 最左前缀原则

B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录。索引项是按照索引定义里面出现的字段顺序排序的。不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。

联合索引内字段顺序安排原则：

第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。权衡联合索引与独立索引的字段选择时，也要考虑空间问题。

##### 索引下推

MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。



##### Cardinality

并不是所有在查询条件中出现的列都需要添加索引。对于什么时候添加B+树索引，一般的经验是，在访问表中很少一部分行时使用B+树索引才有意义。对于性别字段、地区字段、类型字段，它们可取值的范围很小，称为低选择性。相反，如果某个字段的取值范围很广，几乎没有重复，即是高选择性的，那么此时使用B+树索引是最适合的。

怎样查看索引是否是高选择性的呢？可以通过SHOW INDEX语句中的Cardinality列来观察。Cardinality值非常关键，表示索引中唯一只记录数量的预估值。这里需要注意的是， Cardinality是一个预估值，而不是一个准确值，用户也不可能得到一个准确的值。在实际应用中，Cardinality/n_rows_in_table应尽可能接近1，如果非常小，那么需要考虑是否还要建这个索引。因此在访问高选择性属性的字段，并从表中取出很少一部分数据时，对这个字段添加B+树索引是非常有必要的。



#### 索引分类

------

##### 唯一索引与普通索引



- 对于普通索引来说，查找到满足条件的第一个记录后，需要查找下一个记录，直到碰到第一个不满足条件的记录。
- 对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。

这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。所以，我建议你尽量选择普通索引。

**change buffer**，适用于写多读少的业务场景。

当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。

需要说明的是，虽然名字叫作 change buffer，实际上它是可以持久化的数据。也就是说，change buffer 在内存中有拷贝，也会被写入到磁盘上。

将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作。

对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了。因此，唯一索引的更新就不能使用 change buffer，实际上也只有普通索引可以使用。

change buffer 用的是 buffer pool 里的内存，因此不能无限增大。change buffer 的大小，可以通过参数 innodb_change_buffer_max_size 来动态设置。这个参数设置为 50 的时候，表示 change buffer 的大小最多只能占用 buffer pool 的 50%。

如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭 change buffer。而在其他情况下，change buffer 都能提升更新性能。



WAL 是啥？



##### 哈希索引与自适应哈希索引

当前MySQL数据库中，Memory存储引擎支持哈希索引。InnoDB存储引擎支持自适应哈希索引，用户仅能开启该特性，不能对其进行人工干预。





